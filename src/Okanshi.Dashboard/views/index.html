@Master['master.html']

@Section['Header']
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.6/d3.min.js" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.10.6/moment.min.js" charset="utf-8"></script>
<style>
	.line {
		fill: none;
		stroke: steelblue;
		stroke-width: 1.5px;
	}
	.chartdiv {
		display: inline;
	}
</style>
@EndSection

@Section['Content']
<script>
	var margin = { top: 20, right: 20, left: 20, bottom: 30 },
		width = 250 - margin.left - margin.right,
		height = 100 - margin.top - margin.bottom,
		chartWidth = 150,
		chartHeight = 50;
	function mapMeasurement(measurements, windowSize) {
		measurements.reverse();
		var duration = moment.duration(windowSize / 2);
		var elements = [];
		measurements.forEach(function (e, i, array) {
			var time = moment(e.startTime).add(duration);
			elements.push({ time: time.toDate(), average: e.average });
			var nextIndex = i + 1;
			if (array.length <= nextIndex) { return; }
			var nextElement = array[nextIndex];
			var nextStartTime = moment(nextElement.startTime);
			var firstEmptyPointTime = moment(e.endTime).add(duration);
			if (firstEmptyPointTime.isBefore(nextStartTime)) {
				elements.push({ time: firstEmptyPointTime.toDate(), average: 0 });
				var lastEmptyPointTime = nextStartTime.subtract(duration);
				if (lastEmptyPointTime.isAfter(firstEmptyPointTime)) {
					elements.push({ time: lastEmptyPointTime.toDate(), average: 0 });
				}
			}
		});
		var max = d3.max(elements, function (d) { return d.time; });
		var current = new Date();
		if (max < current) {
			var time = moment(max).add(duration).toDate();
			elements.push({ time: time, average: 0 }, { time: current, average: 0 });
		}
		return elements;
	}
	@Each
	d3.json("/instance/@Current.Name", function(error, data) {
		var div = d3.select("body")
			.append("div")
				.attr("id", "@Current.Name");
		div.append("h3").html("@Current.Name");
		if (error) {
			div.append("p").html("Got error while getting data: " + error.statusText);
			return;
		}
		var metrics = _.keys(data).map(function(elm) {
			return {
				name: elm,
				measurements: mapMeasurement(data[elm].measurements, data[elm].windowSize)
			}
		});
		_.each(metrics, function (e) {
			var x = d3.time.scale()
				.range([0, chartWidth])
				.domain(d3.extent(e.measurements, function (d) { return d.time; }));
			var y = d3.scale.linear()
				.range([chartHeight, 0])
				.domain(d3.extent(e.measurements, function (d) { return d.average; }));
			var line = d3.svg.line()
				.x(function (d) { return x(d.time); })
				.y(function (d) { return y(d.average); });
			var chartDiv = div.append("div")
				.attr("class", "chartdiv");
			var svg = chartDiv.append("svg")
					.attr("width", width + margin.left + margin.right)
					.attr("height", height + margin.top + margin.bottom)
				.append("g")
					.attr("transform", "translate(" + margin.left + ", " + margin.right + ")");
			var header = svg.selectAll("text")
				.data([e])
				.enter()
					.append("text")
						.text(function (d) { return d.name; })
						.attr("font-family", "sans-serif")
						.attr("font-size", "15px")
						.attr("fill", "black");
			var grouping = svg.append("g")
				.attr("transform", "translate(0, 10)");
			var averageLine = grouping.append("path")
					.datum(e.measurements)
					.attr("class", "line")
					.attr("d", line);
		});
	});
	@EndEach
</script>
@EndSection